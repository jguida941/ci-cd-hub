"""Scaffold minimal fixture repositories."""

from __future__ import annotations

import argparse
import shutil
from pathlib import Path

from cihub.exit_codes import EXIT_FAILURE, EXIT_SUCCESS, EXIT_USAGE
from cihub.types import CommandResult
from cihub.utils.paths import hub_root

SCAFFOLD_TYPES: dict[str, str] = {
    "python-pyproject": "Minimal Python project with pyproject.toml",
    "python-setup": "Minimal Python project with setup.py",
    "java-maven": "Minimal Java project using Maven",
    "java-gradle": "Minimal Java project using Gradle",
    "monorepo": "Monorepo with java/ and python/ subdirs",
}


def list_scaffold_types() -> list[dict[str, str]]:
    return [{"type": name, "description": desc} for name, desc in SCAFFOLD_TYPES.items()]


def _template_root() -> Path:
    return hub_root() / "templates" / "scaffold"


def _ensure_empty(path: Path, force: bool) -> None:
    if path.exists() and path.is_file():
        raise ValueError(f"Destination is a file: {path}")
    if path.exists() and any(path.iterdir()):
        if not force:
            raise ValueError(f"Destination is not empty: {path}")
        shutil.rmtree(path)
    path.mkdir(parents=True, exist_ok=True)


def _copy_tree(src: Path, dest: Path) -> None:
    shutil.copytree(src, dest, dirs_exist_ok=True)


def _list_files(root: Path) -> list[str]:
    return [str(path) for path in sorted(root.rglob("*")) if path.is_file()]


def scaffold_fixture(fixture_type: str, dest: Path, force: bool = False) -> list[str]:
    if fixture_type not in SCAFFOLD_TYPES:
        raise ValueError(f"Unknown fixture type: {fixture_type}")

    template_root = _template_root()
    _ensure_empty(dest, force)

    if fixture_type == "monorepo":
        (dest / "README.md").write_text(
            "Monorepo scaffold generated by cihub.\n",
            encoding="utf-8",
        )
        _copy_tree(template_root / "java-maven", dest / "java")
        _copy_tree(template_root / "python-pyproject", dest / "python")
    else:
        template_dir = template_root / fixture_type
        if not template_dir.exists():
            raise ValueError(f"Missing scaffold template: {template_dir}")
        _copy_tree(template_dir, dest)

    return _list_files(dest)


def cmd_scaffold(args: argparse.Namespace) -> CommandResult:
    """Scaffold a minimal fixture repository.

    Always returns CommandResult for consistent output handling.
    """
    if args.list:
        data = {"fixtures": list_scaffold_types()}
        items = [f"{entry['type']}: {entry['description']}" for entry in data["fixtures"]]
        return CommandResult(
            exit_code=EXIT_SUCCESS,
            summary="Available fixtures",
            data={"items": items, "fixtures": data["fixtures"]},
        )

    fixture_type = args.type
    dest = Path(args.path or "").resolve()

    if not fixture_type or not args.path:
        message = "type and path are required unless --list is used"
        return CommandResult(
            exit_code=EXIT_USAGE,
            summary=message,
            problems=[{"severity": "error", "message": message, "code": "CIHUB-SCAFFOLD-001"}],
        )

    try:
        files = scaffold_fixture(fixture_type, dest, force=bool(args.force))
    except ValueError as exc:
        return CommandResult(
            exit_code=EXIT_FAILURE,
            summary=str(exc),
            problems=[{"severity": "error", "message": str(exc), "code": "CIHUB-SCAFFOLD-002"}],
        )

    summary = f"Scaffolded {fixture_type} at {dest}"
    return CommandResult(
        exit_code=EXIT_SUCCESS,
        summary=summary,
        files_generated=files,
        data={
            "items": [summary],
            "type": fixture_type,
            "path": str(dest),
            "files": files,
        },
    )
